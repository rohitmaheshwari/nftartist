!function (e) { var t = {}; function i(s) { if (t[s]) return t[s].exports; var n = t[s] = { i: s, l: !1, exports: {} }; return e[s].call(n.exports, n, n.exports, i), n.l = !0, n.exports } i.m = e, i.c = t, i.d = function (e, t, s) { i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: s }) }, i.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.t = function (e, t) { if (1 & t && (e = i(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var s = Object.create(null); if (i.r(s), Object.defineProperty(s, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var n in e) i.d(s, n, function (t) { return e[t] }.bind(null, n)); return s }, i.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return i.d(t, "a", t), t }, i.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, i.p = "/build/", i(i.s = "Z2PJ") }({ "OXL+": function (e, t) { window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = function (e, t) { t = t || window; for (var i = 0; i < this.length; i++)e.call(t, this[i], i, this) }), [Element.prototype, CharacterData.prototype, DocumentType.prototype].forEach((function (e) { e.hasOwnProperty("remove") || Object.defineProperty(e, "remove", { configurable: !0, enumerable: !0, writable: !0, value: function () { null !== this.parentNode && this.parentNode.removeChild(this) } }) })), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (e) { var t = this; do { if (Element.prototype.matches.call(t, e)) return t; t = t.parentElement || t.parentNode } while (null !== t && 1 === t.nodeType); return null }) }, Z2PJ: function (e, t, i) { "use strict"; function s(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function n(e) { return e[e.length - 1] } function a(e, ...t) { return t.forEach(t => { e.includes(t) || e.push(t) }), e } function r(e, t) { return e ? e.split(t) : [] } function o(e, t, i) { return (void 0 === t || e >= t) && (void 0 === i || e <= i) } function d(e, t, i) { return e < t ? t : e > i ? i : e } function c(e, t, i = {}, s = 0, n = "") { n += `<${Object.keys(i).reduce((e, t) => { let n = i[t]; return "function" == typeof n && (n = n(s)), `${e} ${t}="${n}"` }, e)}></${e}>`; const a = s + 1; return a < t ? c(e, t, i, a, n) : n } function l(e) { return e.replace(/>\s+/g, ">").replace(/\s+</, "<") } function h(e) { return new Date(e).setHours(0, 0, 0, 0) } function u() { return (new Date).setHours(0, 0, 0, 0) } function f(...e) { switch (e.length) { case 0: return u(); case 1: return h(e[0]) }const t = new Date(0); return t.setFullYear(...e), t.setHours(0, 0, 0, 0) } function p(e, t) { const i = new Date(e); return i.setDate(i.getDate() + t) } function m(e, t) { const i = new Date(e), s = i.getMonth() + t; let n = s % 12; n < 0 && (n += 12); const a = i.setMonth(s); return i.getMonth() !== n ? i.setDate(0) : a } function g(e, t) { const i = new Date(e), s = i.getMonth(), n = i.setFullYear(i.getFullYear() + t); return 1 === s && 2 === i.getMonth() ? i.setDate(0) : n } function y(e, t) { return (e - t + 7) % 7 } function w(e, t, i = 0) { const s = new Date(e).getDay(); return p(e, y(t, i) - y(s, i)) } function v(e, t) { const i = new Date(e).getFullYear(); return Math.floor(i / t) * t } i.r(t); const b = /dd?|DD?|mm?|MM?|yy?(?:yy)?/, k = /[\s!-/:-@[-`{-~å¹´æœˆæ—¥]+/; let D = {}; const S = { y: (e, t) => new Date(e).setFullYear(parseInt(t, 10)), m(e, t, i) { const s = new Date(e); let n = parseInt(t, 10) - 1; if (isNaN(n)) { if (!t) return NaN; const e = t.toLowerCase(), s = t => t.toLowerCase().startsWith(e); if (n = i.monthsShort.findIndex(s), n < 0 && (n = i.months.findIndex(s)), n < 0) return NaN } return s.setMonth(n), s.getMonth() !== function e(t) { return t > -1 ? t % 12 : e(t + 12) }(n) ? s.setDate(0) : s.getTime() }, d: (e, t) => new Date(e).setDate(parseInt(t, 10)) }, x = { d: e => e.getDate(), dd: e => M(e.getDate(), 2), D: (e, t) => t.daysShort[e.getDay()], DD: (e, t) => t.days[e.getDay()], m: e => e.getMonth() + 1, mm: e => M(e.getMonth() + 1, 2), M: (e, t) => t.monthsShort[e.getMonth()], MM: (e, t) => t.months[e.getMonth()], y: e => e.getFullYear(), yy: e => M(e.getFullYear(), 2).slice(-2), yyyy: e => M(e.getFullYear(), 4) }; function M(e, t) { return e.toString().padStart(t, "0") } function E(e) { if ("string" != typeof e) throw new Error("Invalid date format."); if (e in D) return D[e]; const t = e.split(b), i = e.match(new RegExp(b, "g")); if (0 === t.length || !i) throw new Error("Invalid date format."); const s = i.map(e => x[e]), a = Object.keys(S).reduce((e, t) => (i.find(e => "D" !== e[0] && e[0].toLowerCase() === t) && e.push(t), e), []); return D[e] = { parser(e, t) { const s = e.split(k).reduce((e, t, s) => { if (t.length > 0 && i[s]) { const n = i[s][0]; "M" === n ? e.m = t : "D" !== n && (e[n] = t) } return e }, {}); return a.reduce((e, i) => { const n = S[i](e, s[i], t); return isNaN(n) ? e : n }, u()) }, formatter: (e, i) => s.reduce((s, n, a) => s + `${t[a]}${n(e, i)}`, "") + n(t) } } function C(e, t, i) { if (e instanceof Date || "number" == typeof e) { const t = h(e); return isNaN(t) ? void 0 : t } if (e) { if ("today" === e) return u(); if (t && t.toValue) { const s = t.toValue(e, t, i); return isNaN(s) ? void 0 : h(s) } return E(t).parser(e, i) } } function O(e, t, i) { if (isNaN(e) || !e && 0 !== e) return ""; const s = "number" == typeof e ? new Date(e) : e; return t.toDisplay ? t.toDisplay(s, t, i) : E(t).formatter(s, i) } const N = new WeakMap, { addEventListener: A, removeEventListener: V } = EventTarget.prototype; function F(e, t) { let i = N.get(e); i || (i = [], N.set(e, i)), t.forEach(e => { A.call(...e), i.push(e) }) } function L(e) { let t = N.get(e); t && (t.forEach(e => { V.call(...e) }), N.delete(e)) } if (!Event.prototype.composedPath) { const e = (t, i = []) => { let s; return i.push(t), t.parentNode ? s = t.parentNode : t.host ? s = t.host : t.defaultView && (s = t.defaultView), s ? e(s, i) : i }; Event.prototype.composedPath = function () { return e(this.target) } } function B(e, t) { const i = "function" == typeof t ? t : e => e.matches(t); return function e(t, i, s, n = 0) { const a = t[n]; return i(a) ? a : a !== s && a.parentElement ? e(t, i, s, n + 1) : void 0 }(e.composedPath(), i, e.currentTarget) } const Y = { en: { days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], today: "Today", clear: "Clear", titleFormat: "MM y" } }; var W = { autohide: !1, beforeShowDay: null, beforeShowDecade: null, beforeShowMonth: null, beforeShowYear: null, calendarWeeks: !1, clearBtn: !1, dateDelimiter: ",", datesDisabled: [], daysOfWeekDisabled: [], daysOfWeekHighlighted: [], defaultViewDate: void 0, disableTouchKeyboard: !1, format: "mm/dd/yyyy", language: "en", maxDate: null, maxNumberOfDates: 1, maxView: 3, minDate: null, nextArrow: "Â»", orientation: "auto", pickLevel: 0, prevArrow: "Â«", showDaysOfWeek: !0, showOnClick: !0, showOnFocus: !0, startView: 0, title: "", todayBtn: !1, todayBtnMode: 0, todayHighlight: !1, updateOnBlur: !0, weekStart: 0 }; const P = document.createRange(); function j(e) { return P.createContextualFragment(e) } function T(e) { "none" !== e.style.display && (e.style.display && (e.dataset.styleDisplay = e.style.display), e.style.display = "none") } function q(e) { "none" === e.style.display && (e.dataset.styleDisplay ? (e.style.display = e.dataset.styleDisplay, delete e.dataset.styleDisplay) : e.style.display = "") } function _(e) { e.firstChild && (e.removeChild(e.firstChild), _(e)) } const { language: K, format: H, weekStart: I } = W; function R(e, t) { return e.length < 6 && t >= 0 && t < 7 ? a(e, t) : e } function $(e) { return (e + 6) % 7 } function J(e, t, i, s) { const n = C(e, t, i); return void 0 !== n ? n : s } function U(e, t, i = 3) { const s = parseInt(e, 10); return s >= 0 && s <= i ? s : t } function X(e, t) { const i = Object.assign({}, e), n = {}, r = t.constructor.locales; let { format: o, language: d, locale: c, maxDate: l, maxView: h, minDate: u, pickLevel: p, startView: m, weekStart: g } = t.config || {}; if (i.language) { let e; if (i.language !== d && (r[i.language] ? e = i.language : (e = i.language.split("-")[0], void 0 === r[e] && (e = !1))), delete i.language, e) { d = n.language = e; const t = c || r[K]; c = Object.assign({ format: H, weekStart: I }, r[K]), d !== K && Object.assign(c, r[d]), n.locale = c, o === t.format && (o = n.format = c.format), g === t.weekStart && (g = n.weekStart = c.weekStart, n.weekEnd = $(c.weekStart)) } } if (i.format) { const e = "function" == typeof i.format.toDisplay, t = "function" == typeof i.format.toValue, s = b.test(i.format); (e && t || s) && (o = n.format = i.format), delete i.format } let y = u, w = l; if (void 0 !== i.minDate && (y = null === i.minDate ? f(0, 0, 1) : J(i.minDate, o, c, y), delete i.minDate), void 0 !== i.maxDate && (w = null === i.maxDate ? void 0 : J(i.maxDate, o, c, w), delete i.maxDate), w < y ? (u = n.minDate = w, l = n.maxDate = y) : (u !== y && (u = n.minDate = y), l !== w && (l = n.maxDate = w)), i.datesDisabled && (n.datesDisabled = i.datesDisabled.reduce((e, t) => { const i = C(t, o, c); return void 0 !== i ? a(e, i) : e }, []), delete i.datesDisabled), void 0 !== i.defaultViewDate) { const e = C(i.defaultViewDate, o, c); void 0 !== e && (n.defaultViewDate = e), delete i.defaultViewDate } if (void 0 !== i.weekStart) { const e = Number(i.weekStart) % 7; isNaN(e) || (g = n.weekStart = e, n.weekEnd = $(e)), delete i.weekStart } if (i.daysOfWeekDisabled && (n.daysOfWeekDisabled = i.daysOfWeekDisabled.reduce(R, []), delete i.daysOfWeekDisabled), i.daysOfWeekHighlighted && (n.daysOfWeekHighlighted = i.daysOfWeekHighlighted.reduce(R, []), delete i.daysOfWeekHighlighted), void 0 !== i.maxNumberOfDates) { const e = parseInt(i.maxNumberOfDates, 10); e >= 0 && (n.maxNumberOfDates = e, n.multidate = 1 !== e), delete i.maxNumberOfDates } i.dateDelimiter && (n.dateDelimiter = String(i.dateDelimiter), delete i.dateDelimiter); let v = p; void 0 !== i.pickLevel && (v = U(i.pickLevel, 2), delete i.pickLevel), v !== p && (p = n.pickLevel = v); let k = h; void 0 !== i.maxView && (k = U(i.maxView, h), delete i.maxView), k = p > k ? p : k, k !== h && (h = n.maxView = k); let D = m; if (void 0 !== i.startView && (D = U(i.startView, D), delete i.startView), D < p ? D = p : D > h && (D = h), D !== m && (n.startView = D), i.prevArrow) { const e = j(i.prevArrow); e.childNodes.length > 0 && (n.prevArrow = e.childNodes), delete i.prevArrow } if (i.nextArrow) { const e = j(i.nextArrow); e.childNodes.length > 0 && (n.nextArrow = e.childNodes), delete i.nextArrow } if (void 0 !== i.disableTouchKeyboard && (n.disableTouchKeyboard = "ontouchstart" in document && !!i.disableTouchKeyboard, delete i.disableTouchKeyboard), i.orientation) { const e = i.orientation.toLowerCase().split(/\s+/g); n.orientation = { x: e.find(e => "left" === e || "right" === e) || "auto", y: e.find(e => "top" === e || "bottom" === e) || "auto" }, delete i.orientation } if (void 0 !== i.todayBtnMode) { switch (i.todayBtnMode) { case 0: case 1: n.todayBtnMode = i.todayBtnMode }delete i.todayBtnMode } return Object.keys(i).forEach(e => { void 0 !== i[e] && s(W, e) && (n[e] = i[e]) }), n } var Z = l('<div class="datepicker">\n  <div class="datepicker-picker">\n    <div class="datepicker-header">\n      <div class="datepicker-title"></div>\n      <div class="datepicker-controls">\n        <button type="button" class="%buttonClass% prev-btn"></button>\n        <button type="button" class="%buttonClass% view-switch"></button>\n        <button type="button" class="%buttonClass% next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls">\n        <button type="button" class="%buttonClass% today-btn"></button>\n        <button type="button" class="%buttonClass% clear-btn"></button>\n      </div>\n    </div>\n  </div>\n</div>'); var z = l(`<div class="days">\n  <div class="days-of-week">${c("span", 7, { class: "dow" })}</div>\n  <div class="datepicker-grid">${c("span", 42)}</div>\n</div>`); var G = l(`<div class="calendar-weeks">\n  <div class="days-of-week"><span class="dow"></span></div>\n  <div class="weeks">${c("span", 6, { class: "week" })}</div>\n</div>`); class Q { constructor(e, t) { Object.assign(this, t, { picker: e, element: j('<div class="datepicker-view"></div>').firstChild, selected: [] }), this.init(this.picker.datepicker.config) } init(e) { void 0 !== e.pickLevel && (this.isMinView = this.id === e.pickLevel), this.setOptions(e), this.updateFocus(), this.updateSelection() } performBeforeHook(e, t, i) { let s = this.beforeShow(new Date(i)); switch (typeof s) { case "boolean": s = { enabled: s }; break; case "string": s = { classes: s } }if (s) { if (!1 === s.enabled && (e.classList.add("disabled"), a(this.disabled, t)), s.classes) { const i = s.classes.split(/\s+/); e.classList.add(...i), i.includes("disabled") && a(this.disabled, t) } s.content && function (e, t) { _(e), t instanceof DocumentFragment ? e.appendChild(t) : "string" == typeof t ? e.appendChild(j(t)) : "function" == typeof t.forEach && t.forEach(t => { e.appendChild(t) }) }(e, s.content) } } } class ee extends Q { constructor(e) { super(e, { id: 0, name: "days", cellClass: "day" }) } init(e, t = !0) { if (t) { const e = j(z).firstChild; this.dow = e.firstChild, this.grid = e.lastChild, this.element.appendChild(e) } super.init(e) } setOptions(e) { let t; if (s(e, "minDate") && (this.minDate = e.minDate), s(e, "maxDate") && (this.maxDate = e.maxDate), e.datesDisabled && (this.datesDisabled = e.datesDisabled), e.daysOfWeekDisabled && (this.daysOfWeekDisabled = e.daysOfWeekDisabled, t = !0), e.daysOfWeekHighlighted && (this.daysOfWeekHighlighted = e.daysOfWeekHighlighted), void 0 !== e.todayHighlight && (this.todayHighlight = e.todayHighlight), void 0 !== e.weekStart && (this.weekStart = e.weekStart, this.weekEnd = e.weekEnd, t = !0), e.locale) { const i = this.locale = e.locale; this.dayNames = i.daysMin, this.switchLabelFormat = i.titleFormat, t = !0 } if (void 0 !== e.beforeShowDay && (this.beforeShow = "function" == typeof e.beforeShowDay ? e.beforeShowDay : void 0), void 0 !== e.calendarWeeks) if (e.calendarWeeks && !this.calendarWeeks) { const e = j(G).firstChild; this.calendarWeeks = { element: e, dow: e.firstChild, weeks: e.lastChild }, this.element.insertBefore(e, this.element.firstChild) } else this.calendarWeeks && !e.calendarWeeks && (this.element.removeChild(this.calendarWeeks.element), this.calendarWeeks = null); void 0 !== e.showDaysOfWeek && (e.showDaysOfWeek ? (q(this.dow), this.calendarWeeks && q(this.calendarWeeks.dow)) : (T(this.dow), this.calendarWeeks && T(this.calendarWeeks.dow))), t && Array.from(this.dow.children).forEach((e, t) => { const i = (this.weekStart + t) % 7; e.textContent = this.dayNames[i], e.className = this.daysOfWeekDisabled.includes(i) ? "dow disabled" : "dow" }) } updateFocus() { const e = new Date(this.picker.viewDate), t = e.getFullYear(), i = e.getMonth(), s = f(t, i, 1), n = w(s, this.weekStart, this.weekStart); this.first = s, this.last = f(t, i + 1, 0), this.start = n, this.focused = this.picker.viewDate } updateSelection() { const { dates: e, rangepicker: t } = this.picker.datepicker; this.selected = e, t && (this.range = t.dates) } render() { this.today = this.todayHighlight ? u() : void 0, this.disabled = [...this.datesDisabled]; const e = O(this.focused, this.switchLabelFormat, this.locale); if (this.picker.setViewSwitchLabel(e), this.picker.setPrevBtnDisabled(this.first <= this.minDate), this.picker.setNextBtnDisabled(this.last >= this.maxDate), this.calendarWeeks) { const e = w(this.first, 1, 1); Array.from(this.calendarWeeks.weeks.children).forEach((t, i) => { t.textContent = function (e) { const t = w(e, 4, 1), i = w(new Date(t).setMonth(0, 4), 4, 1); return Math.round((t - i) / 6048e5) + 1 }(p(e, 7 * i)) }) } Array.from(this.grid.children).forEach((e, t) => { const i = e.classList, s = p(this.start, t), n = new Date(s), r = n.getDay(); if (e.className = "datepicker-cell " + this.cellClass, e.dataset.date = s, e.textContent = n.getDate(), s < this.first ? i.add("prev") : s > this.last && i.add("next"), this.today === s && i.add("today"), (s < this.minDate || s > this.maxDate || this.disabled.includes(s)) && i.add("disabled"), this.daysOfWeekDisabled.includes(r) && (i.add("disabled"), a(this.disabled, s)), this.daysOfWeekHighlighted.includes(r) && i.add("highlighted"), this.range) { const [e, t] = this.range; s > e && s < t && i.add("range"), s === e && i.add("range-start"), s === t && i.add("range-end") } this.selected.includes(s) && i.add("selected"), s === this.focused && i.add("focused"), this.beforeShow && this.performBeforeHook(e, s, s) }) } refresh() { const [e, t] = this.range || []; this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(e => { e.classList.remove("range", "range-start", "range-end", "selected", "focused") }), Array.from(this.grid.children).forEach(i => { const s = Number(i.dataset.date), n = i.classList; s > e && s < t && n.add("range"), s === e && n.add("range-start"), s === t && n.add("range-end"), this.selected.includes(s) && n.add("selected"), s === this.focused && n.add("focused") }) } refreshFocus() { const e = Math.round((this.focused - this.start) / 864e5); this.grid.querySelectorAll(".focused").forEach(e => { e.classList.remove("focused") }), this.grid.children[e].classList.add("focused") } } function te(e, t) { if (!e || !e[0] || !e[1]) return; const [[i, s], [n, a]] = e; return i > t || n < t ? void 0 : [i === t ? s : -1, n === t ? a : 12] } class ie extends Q { constructor(e) { super(e, { id: 1, name: "months", cellClass: "month" }) } init(e, t = !0) { t && (this.grid = this.element, this.element.classList.add("months", "datepicker-grid"), this.grid.appendChild(j(c("span", 12, { "data-month": e => e })))), super.init(e) } setOptions(e) { if (e.locale && (this.monthNames = e.locale.monthsShort), s(e, "minDate")) if (void 0 === e.minDate) this.minYear = this.minMonth = this.minDate = void 0; else { const t = new Date(e.minDate); this.minYear = t.getFullYear(), this.minMonth = t.getMonth(), this.minDate = t.setDate(1) } if (s(e, "maxDate")) if (void 0 === e.maxDate) this.maxYear = this.maxMonth = this.maxDate = void 0; else { const t = new Date(e.maxDate); this.maxYear = t.getFullYear(), this.maxMonth = t.getMonth(), this.maxDate = f(this.maxYear, this.maxMonth + 1, 0) } void 0 !== e.beforeShowMonth && (this.beforeShow = "function" == typeof e.beforeShowMonth ? e.beforeShowMonth : void 0) } updateFocus() { const e = new Date(this.picker.viewDate); this.year = e.getFullYear(), this.focused = e.getMonth() } updateSelection() { const { dates: e, rangepicker: t } = this.picker.datepicker; this.selected = e.reduce((e, t) => { const i = new Date(t), s = i.getFullYear(), n = i.getMonth(); return void 0 === e[s] ? e[s] = [n] : a(e[s], n), e }, {}), t && t.dates && (this.range = t.dates.map(e => { const t = new Date(e); return isNaN(t) ? void 0 : [t.getFullYear(), t.getMonth()] })) } render() { this.disabled = [], this.picker.setViewSwitchLabel(this.year), this.picker.setPrevBtnDisabled(this.year <= this.minYear), this.picker.setNextBtnDisabled(this.year >= this.maxYear); const e = this.selected[this.year] || [], t = this.year < this.minYear || this.year > this.maxYear, i = this.year === this.minYear, s = this.year === this.maxYear, n = te(this.range, this.year); Array.from(this.grid.children).forEach((a, r) => { const o = a.classList, d = f(this.year, r, 1); if (a.className = "datepicker-cell " + this.cellClass, this.isMinView && (a.dataset.date = d), a.textContent = this.monthNames[r], (t || i && r < this.minMonth || s && r > this.maxMonth) && o.add("disabled"), n) { const [e, t] = n; r > e && r < t && o.add("range"), r === e && o.add("range-start"), r === t && o.add("range-end") } e.includes(r) && o.add("selected"), r === this.focused && o.add("focused"), this.beforeShow && this.performBeforeHook(a, r, d) }) } refresh() { const e = this.selected[this.year] || [], [t, i] = te(this.range, this.year) || []; this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(e => { e.classList.remove("range", "range-start", "range-end", "selected", "focused") }), Array.from(this.grid.children).forEach((s, n) => { const a = s.classList; n > t && n < i && a.add("range"), n === t && a.add("range-start"), n === i && a.add("range-end"), e.includes(n) && a.add("selected"), n === this.focused && a.add("focused") }) } refreshFocus() { this.grid.querySelectorAll(".focused").forEach(e => { e.classList.remove("focused") }), this.grid.children[this.focused].classList.add("focused") } } class se extends Q { constructor(e, t) { super(e, t) } init(e, t = !0) { var i; t && (this.navStep = 10 * this.step, this.beforeShowOption = "beforeShow" + (i = this.cellClass, [...i].reduce((e, t, i) => e + (i ? t : t.toUpperCase()), "")), this.grid = this.element, this.element.classList.add(this.name, "datepicker-grid"), this.grid.appendChild(j(c("span", 12)))), super.init(e) } setOptions(e) { if (s(e, "minDate") && (void 0 === e.minDate ? this.minYear = this.minDate = void 0 : (this.minYear = v(e.minDate, this.step), this.minDate = f(this.minYear, 0, 1))), s(e, "maxDate") && (void 0 === e.maxDate ? this.maxYear = this.maxDate = void 0 : (this.maxYear = v(e.maxDate, this.step), this.maxDate = f(this.maxYear, 11, 31))), void 0 !== e[this.beforeShowOption]) { const t = e[this.beforeShowOption]; this.beforeShow = "function" == typeof t ? t : void 0 } } updateFocus() { const e = new Date(this.picker.viewDate), t = v(e, this.navStep), i = t + 9 * this.step; this.first = t, this.last = i, this.start = t - this.step, this.focused = v(e, this.step) } updateSelection() { const { dates: e, rangepicker: t } = this.picker.datepicker; this.selected = e.reduce((e, t) => a(e, v(t, this.step)), []), t && t.dates && (this.range = t.dates.map(e => { if (void 0 !== e) return v(e, this.step) })) } render() { this.disabled = [], this.picker.setViewSwitchLabel(`${this.first}-${this.last}`), this.picker.setPrevBtnDisabled(this.first <= this.minYear), this.picker.setNextBtnDisabled(this.last >= this.maxYear), Array.from(this.grid.children).forEach((e, t) => { const i = e.classList, s = this.start + t * this.step, n = f(s, 0, 1); if (e.className = "datepicker-cell " + this.cellClass, this.isMinView && (e.dataset.date = n), e.textContent = e.dataset.year = s, 0 === t ? i.add("prev") : 11 === t && i.add("next"), (s < this.minYear || s > this.maxYear) && i.add("disabled"), this.range) { const [e, t] = this.range; s > e && s < t && i.add("range"), s === e && i.add("range-start"), s === t && i.add("range-end") } this.selected.includes(s) && i.add("selected"), s === this.focused && i.add("focused"), this.beforeShow && this.performBeforeHook(e, s, n) }) } refresh() { const [e, t] = this.range || []; this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach(e => { e.classList.remove("range", "range-start", "range-end", "selected", "focused") }), Array.from(this.grid.children).forEach(i => { const s = Number(i.textContent), n = i.classList; s > e && s < t && n.add("range"), s === e && n.add("range-start"), s === t && n.add("range-end"), this.selected.includes(s) && n.add("selected"), s === this.focused && n.add("focused") }) } refreshFocus() { const e = Math.round((this.focused - this.start) / this.step); this.grid.querySelectorAll(".focused").forEach(e => { e.classList.remove("focused") }), this.grid.children[e].classList.add("focused") } } function ne(e, t) { const i = { date: e.getDate(), viewDate: new Date(e.picker.viewDate), viewId: e.picker.currentView.id, datepicker: e }; e.element.dispatchEvent(new CustomEvent(t, { detail: i })) } function ae(e, t) { const { minDate: i, maxDate: s } = e.config, { currentView: n, viewDate: a } = e.picker; let r; switch (n.id) { case 0: r = m(a, t); break; case 1: r = g(a, t); break; default: r = g(a, t * n.navStep) }r = d(r, i, s), e.picker.changeFocus(r).render() } function re(e) { const t = e.picker.currentView.id; t !== e.config.maxView && e.picker.changeView(t + 1).render() } function oe(e) { e.config.updateOnBlur ? e.update({ autohide: !0 }) : (e.refresh("input"), e.hide()) } function de(e, t) { const i = e.picker, s = new Date(i.viewDate), n = i.currentView.id, a = 1 === n ? m(s, t - s.getMonth()) : g(s, t - s.getFullYear()); i.changeFocus(a).changeView(n - 1).render() } function ce(e) { const t = e.picker, i = u(); if (1 === e.config.todayBtnMode) { if (e.config.autohide) return void e.setDate(i); e.setDate(i, { render: !1 }), t.update() } t.viewDate !== i && t.changeFocus(i), t.changeView(0).render() } function le(e) { e.setDate({ clear: !0 }) } function he(e) { re(e) } function ue(e) { ae(e, -1) } function fe(e) { ae(e, 1) } function pe(e, t) { const i = B(t, ".datepicker-cell"); if (!i || i.classList.contains("disabled")) return; const { id: s, isMinView: n } = e.picker.currentView; n ? e.setDate(Number(i.dataset.date)) : de(e, Number(1 === s ? i.dataset.month : i.dataset.year)) } function me(e) { e.inline || e.config.disableTouchKeyboard || e.inputField.focus() } function ge(e, t) { if (void 0 !== t.title && (t.title ? (e.controls.title.textContent = t.title, q(e.controls.title)) : (e.controls.title.textContent = "", T(e.controls.title))), t.prevArrow) { const i = e.controls.prevBtn; _(i), t.prevArrow.forEach(e => { i.appendChild(e.cloneNode(!0)) }) } if (t.nextArrow) { const i = e.controls.nextBtn; _(i), t.nextArrow.forEach(e => { i.appendChild(e.cloneNode(!0)) }) } if (t.locale && (e.controls.todayBtn.textContent = t.locale.today, e.controls.clearBtn.textContent = t.locale.clear), void 0 !== t.todayBtn && (t.todayBtn ? q(e.controls.todayBtn) : T(e.controls.todayBtn)), s(t, "minDate") || s(t, "maxDate")) { const { minDate: t, maxDate: i } = e.datepicker.config; e.controls.todayBtn.disabled = !o(u(), t, i) } void 0 !== t.clearBtn && (t.clearBtn ? q(e.controls.clearBtn) : T(e.controls.clearBtn)) } function ye(e) { const { dates: t, config: i } = e; return d(t.length > 0 ? n(t) : i.defaultViewDate, i.minDate, i.maxDate) } function we(e, t) { const i = new Date(e.viewDate), s = new Date(t), { id: n, year: a, first: r, last: o } = e.currentView, d = s.getFullYear(); switch (e.viewDate = t, d !== i.getFullYear() && ne(e.datepicker, "changeYear"), s.getMonth() !== i.getMonth() && ne(e.datepicker, "changeMonth"), n) { case 0: return t < r || t > o; case 1: return d !== a; default: return d < r || d > o } } function ve(e) { return window.getComputedStyle(e).direction } class be { constructor(e) { this.datepicker = e; const t = Z.replace(/%buttonClass%/g, e.config.buttonClass), i = this.element = j(t).firstChild, [s, n, a] = i.firstChild.children, r = s.firstElementChild, [o, d, c] = s.lastElementChild.children, [l, h] = a.firstChild.children, u = { title: r, prevBtn: o, viewSwitch: d, nextBtn: c, todayBtn: l, clearBtn: h }; this.main = n, this.controls = u; const f = e.inline ? "inline" : "dropdown"; i.classList.add("datepicker-" + f), ge(this, e.config), this.viewDate = ye(e), F(e, [[i, "click", me.bind(null, e), { capture: !0 }], [n, "click", pe.bind(null, e)], [u.viewSwitch, "click", he.bind(null, e)], [u.prevBtn, "click", ue.bind(null, e)], [u.nextBtn, "click", fe.bind(null, e)], [u.todayBtn, "click", ce.bind(null, e)], [u.clearBtn, "click", le.bind(null, e)]]), this.views = [new ee(this), new ie(this), new se(this, { id: 2, name: "years", cellClass: "year", step: 1 }), new se(this, { id: 3, name: "decades", cellClass: "decade", step: 10 })], this.currentView = this.views[e.config.startView], this.currentView.render(), this.main.appendChild(this.currentView.element), e.config.container.appendChild(this.element) } setOptions(e) { ge(this, e), this.views.forEach(t => { t.init(e, !1) }), this.currentView.render() } detach() { this.datepicker.config.container.removeChild(this.element) } show() { if (this.active) return; this.element.classList.add("active"), this.active = !0; const e = this.datepicker; if (!e.inline) { const t = ve(e.inputField); t !== ve(e.config.container) ? this.element.dir = t : this.element.dir && this.element.removeAttribute("dir"), this.place(), e.config.disableTouchKeyboard && e.inputField.blur() } ne(e, "show") } hide() { this.active && (this.datepicker.exitEditMode(), this.element.classList.remove("active"), this.active = !1, ne(this.datepicker, "hide")) } place() { const { classList: e, style: t } = this.element, { config: i, inputField: s } = this.datepicker, n = i.container, { width: a, height: r } = this.element.getBoundingClientRect(), { left: o, top: d, width: c } = n.getBoundingClientRect(), { left: l, top: h, width: u, height: f } = s.getBoundingClientRect(); let p, m, g, { x: y, y: w } = i.orientation; n === document.body ? (p = window.scrollY, m = l + window.scrollX, g = h + p) : (p = n.scrollTop, m = l - o, g = h - d + p), "auto" === y && (m < 0 ? (y = "left", m = 10) : y = m + a > c || "rtl" === ve(s) ? "right" : "left"), "right" === y && (m -= a - u), "auto" === w && (w = g - r < p ? "bottom" : "top"), "top" === w ? g -= r : g += f, e.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left"), e.add("datepicker-orient-" + w, "datepicker-orient-" + y), t.top = g ? g + "px" : g, t.left = m ? m + "px" : m } setViewSwitchLabel(e) { this.controls.viewSwitch.textContent = e } setPrevBtnDisabled(e) { this.controls.prevBtn.disabled = e } setNextBtnDisabled(e) { this.controls.nextBtn.disabled = e } changeView(e) { const t = this.currentView, i = this.views[e]; return i.id !== t.id && (this.currentView = i, this._renderMethod = "render", ne(this.datepicker, "changeView"), this.main.replaceChild(i.element, t.element)), this } changeFocus(e) { return this._renderMethod = we(this, e) ? "render" : "refreshFocus", this.views.forEach(e => { e.updateFocus() }), this } update() { const e = ye(this.datepicker); return this._renderMethod = we(this, e) ? "render" : "refresh", this.views.forEach(e => { e.updateFocus(), e.updateSelection() }), this } render(e = !0) { const t = e && this._renderMethod || "render"; delete this._renderMethod, this.currentView[t]() } } function ke(e, t, i, s) { const n = e.picker, a = n.currentView, r = a.step || 1; let d, c, l = n.viewDate; switch (a.id) { case 0: l = s ? p(l, 7 * i) : t.ctrlKey || t.metaKey ? g(l, i) : p(l, i), d = p, c = e => a.disabled.includes(e); break; case 1: l = m(l, s ? 4 * i : i), d = m, c = e => { const t = new Date(e), { year: i, disabled: s } = a; return t.getFullYear() === i && s.includes(t.getMonth()) }; break; default: l = g(l, i * (s ? 4 : 1) * r), d = g, c = e => a.disabled.includes(v(e, r)) }l = function e(t, i, s, n, a, r) { if (o(t, a, r)) { if (n(t)) { return e(i(t, s), i, s, n, a, r) } return t } }(l, d, i < 0 ? -r : r, c, a.minDate, a.maxDate), void 0 !== l && n.changeFocus(l).render() } function De(e, t) { if ("Tab" === t.key) return void oe(e); const i = e.picker, { id: s, isMinView: n } = i.currentView; if (i.active) if (e.editMode) switch (t.key) { case "Escape": i.hide(); break; case "Enter": e.exitEditMode({ update: !0, autohide: e.config.autohide }); break; default: return } else switch (t.key) { case "Escape": i.hide(); break; case "ArrowLeft": if (t.ctrlKey || t.metaKey) ae(e, -1); else { if (t.shiftKey) return void e.enterEditMode(); ke(e, t, -1, !1) } break; case "ArrowRight": if (t.ctrlKey || t.metaKey) ae(e, 1); else { if (t.shiftKey) return void e.enterEditMode(); ke(e, t, 1, !1) } break; case "ArrowUp": if (t.ctrlKey || t.metaKey) re(e); else { if (t.shiftKey) return void e.enterEditMode(); ke(e, t, -1, !0) } break; case "ArrowDown": if (t.shiftKey && !t.ctrlKey && !t.metaKey) return void e.enterEditMode(); ke(e, t, 1, !0); break; case "Enter": n ? e.setDate(i.viewDate) : i.changeView(s - 1).render(); break; case "Backspace": case "Delete": return void e.enterEditMode(); default: return void (1 !== t.key.length || t.ctrlKey || t.metaKey || e.enterEditMode()) } else switch (t.key) { case "ArrowDown": case "Escape": i.show(); break; case "Enter": e.update(); break; default: return }t.preventDefault(), t.stopPropagation() } function Se(e) { e.config.showOnFocus && !e._showing && e.show() } function xe(e, t) { const i = t.target; (e.picker.active || e.config.showOnClick) && (i._active = i === document.activeElement, i._clicking = setTimeout(() => { delete i._active, delete i._clicking }, 2e3)) } function Me(e, t) { const i = t.target; i._clicking && (clearTimeout(i._clicking), delete i._clicking, i._active && e.enterEditMode(), delete i._active, e.config.showOnClick && e.show()) } function Ee(e, t) { t.clipboardData.types.includes("text/plain") && e.enterEditMode() } function Ce(e, t) { const i = e.element; if (i !== document.activeElement) return; const s = e.picker.element; B(t, e => e === i || e === s) || oe(e) } function Oe(e, t) { return e.map(e => O(e, t.format, t.locale)).join(t.dateDelimiter) } function Ne(e, t, i = !1) { const { config: s, dates: n, rangepicker: a } = e; if (0 === t.length) return i ? [] : void 0; const r = a && e === a.datepickers[1]; let d = t.reduce((e, t) => { let i = C(t, s.format, s.locale); if (void 0 === i) return e; if (s.pickLevel > 0) { const e = new Date(i); i = 1 === s.pickLevel ? r ? e.setMonth(e.getMonth() + 1, 0) : e.setDate(1) : r ? e.setFullYear(e.getFullYear() + 1, 0, 0) : e.setMonth(0, 1) } return !o(i, s.minDate, s.maxDate) || e.includes(i) || s.datesDisabled.includes(i) || s.daysOfWeekDisabled.includes(new Date(i).getDay()) || e.push(i), e }, []); return 0 !== d.length ? (s.multidate && !i && (d = d.reduce((e, t) => (n.includes(t) || e.push(t), e), n.filter(e => !d.includes(e)))), s.maxNumberOfDates && d.length > s.maxNumberOfDates ? d.slice(-1 * s.maxNumberOfDates) : d) : void 0 } function Ae(e, t = 3, i = !0) { const { config: s, picker: n, inputField: a } = e; if (2 & t) { const e = n.active ? s.pickLevel : s.startView; n.update().changeView(e).render(i) } 1 & t && a && (a.value = Oe(e.dates, s)) } function Ve(e, t, i) { let { clear: s, render: n, autohide: a } = i; void 0 === n && (n = !0), n ? void 0 === a && (a = e.config.autohide) : a = !1; const r = Ne(e, t, s); r && (r.toString() !== e.dates.toString() ? (e.dates = r, Ae(e, n ? 3 : 1), ne(e, "changeDate")) : Ae(e, 1), a && e.hide()) } class Fe { constructor(e, t = {}, i) { e.datepicker = this, this.element = e; const s = this.config = Object.assign({ buttonClass: t.buttonClass && String(t.buttonClass) || "button", container: document.body, defaultViewDate: u(), maxDate: void 0, minDate: void 0 }, X(W, this)); this._options = t, Object.assign(s, X(t, this)); const n = this.inline = "INPUT" !== e.tagName; let a, o; if (n) s.container = e, o = r(e.dataset.date, s.dateDelimiter), delete e.dataset.date; else { const i = t.container ? document.querySelector(t.container) : null; i && (s.container = i), a = this.inputField = e, a.classList.add("datepicker-input"), o = r(a.value, s.dateDelimiter) } if (i) { const e = i.inputs.indexOf(a), t = i.datepickers; if (e < 0 || e > 1 || !Array.isArray(t)) throw Error("Invalid rangepicker object."); t[e] = this, Object.defineProperty(this, "rangepicker", { get: () => i }) } this.dates = []; const d = Ne(this, o); d && d.length > 0 && (this.dates = d), a && (a.value = Oe(this.dates, s)); const c = this.picker = new be(this); if (n) this.show(); else { const e = Ce.bind(null, this); F(this, [[a, "keydown", De.bind(null, this)], [a, "focus", Se.bind(null, this)], [a, "mousedown", xe.bind(null, this)], [a, "click", Me.bind(null, this)], [a, "paste", Ee.bind(null, this)], [document, "mousedown", e], [document, "touchstart", e], [window, "resize", c.place.bind(c)]]) } } static formatDate(e, t, i) { return O(e, t, i && Y[i] || Y.en) } static parseDate(e, t, i) { return C(e, t, i && Y[i] || Y.en) } static get locales() { return Y } get active() { return !(!this.picker || !this.picker.active) } get pickerElement() { return this.picker ? this.picker.element : void 0 } setOptions(e) { const t = this.picker, i = X(e, this); Object.assign(this._options, e), Object.assign(this.config, i), t.setOptions(i), Ae(this, 3) } show() { if (this.inputField) { if (this.inputField.disabled) return; this.inputField !== document.activeElement && (this._showing = !0, this.inputField.focus(), delete this._showing) } this.picker.show() } hide() { this.inline || (this.picker.hide(), this.picker.update().changeView(this.config.startView).render()) } destroy() { return this.hide(), L(this), this.picker.detach(), this.inline || this.inputField.classList.remove("datepicker-input"), delete this.element.datepicker, this } getDate(e) { const t = e ? t => O(t, e, this.config.locale) : e => new Date(e); return this.config.multidate ? this.dates.map(t) : this.dates.length > 0 ? t(this.dates[0]) : void 0 } setDate(...e) { const t = [...e], i = {}, s = n(e); "object" != typeof s || Array.isArray(s) || s instanceof Date || !s || Object.assign(i, t.pop()); Ve(this, Array.isArray(t[0]) ? t[0] : t, i) } update(e) { if (this.inline) return; const t = { clear: !0, autohide: !(!e || !e.autohide) }; Ve(this, r(this.inputField.value, this.config.dateDelimiter), t) } refresh(e, t = !1) { let i; e && "string" != typeof e && (t = e, e = void 0), i = "picker" === e ? 2 : "input" === e ? 1 : 3, Ae(this, i, !t) } enterEditMode() { this.inline || !this.picker.active || this.editMode || (this.editMode = !0, this.inputField.classList.add("in-edit")) } exitEditMode(e) { if (this.inline || !this.editMode) return; const t = Object.assign({ update: !1 }, e); delete this.editMode, this.inputField.classList.remove("in-edit"), t.update && this.update(t) } } i("OXL+"); var Le = { defaultMessages: { success: "Thanks for subscribing!", missingEmailAddress: "Your email address is required.", invalidEmailAddress: "Your email address looks incorrect, please try again.", botSubmissionError: "This doesn't look like a human submission.", consentRequired: "Please check the checkbox to indicate your consent.", invalidParametersError: "This form has missing or invalid fields.", unknownError: "Sorry, an unknown error has occurred. Please try again later." }, getMessage: function (e) { var t = "messages." + e.toLowerCase(), i = document.querySelector('meta[name="' + t + '"]'); return i ? i.content : this.defaultMessages[e] }, isBotPost: function (e) { var t = e.querySelector(".emailoctopus-form-row-hp input"); return Boolean(t.value) }, isEmailAddressValid: function (e) { var t = e.querySelector("input[type=email]").value.trim(); return /\S+@\S+\.\S+/.test(t) }, hasEmailAddressBeenEntered: function (e) { var t = e.querySelector("input[type=email]").value.trim(); return Boolean(t) }, consentRequired: function (e) { var t = e.querySelector(".emailoctopus-form-row-consent input"); return Boolean(t && !t.checked) }, shouldRedirect: function () { return "true" === document.querySelector('meta[name="redirectOnSubmit.enabled"]').content }, getRedirectUrl: function () { var e = document.querySelector('meta[name="redirectOnSubmit.url"]'); return e ? e.content.trim() : null }, redirect: function (e) { window.top.location.href = e }, showConfirmation: function (e) { e.style.display = "none", e.parentNode.querySelector(".emailoctopus-success-message").textContent = this.getMessage("success") }, ajaxSuccess: function (e) { this.shouldRedirect(e) ? this.redirect(this.getRedirectUrl(e)) : this.showConfirmation(e) }, ajaxError: function (e, t) { if (t && t.error && t.error.code) switch (t.error.code) { case "INVALID_PARAMETERS": return void this.onError(e, this.getMessage("invalidParametersError")); case "BOT_SUBMISSION": return void this.onError(e, this.getMessage("botSubmissionError")) }this.onError(e, this.getMessage("unknownError")) }, ajaxSubmit: function (e) { var t = this; e.querySelector("[type=submit]").setAttribute("disabled", !0); var i = Array.from(e.querySelectorAll("input[name]")).reduce((function (e, t) { return (e ? e + "&" : "") + (encodeURIComponent(t.getAttribute("name")) + "=") + encodeURIComponent(t.value) }), ""); fetch(window.location.href, { method: "POST", mode: "cors", cache: "no-cache", credentials: "include", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: i }).then((function (e) { return e.json() })).then((function (i) { i.success ? t.ajaxSuccess(e) : t.ajaxError(e) })) }, onError: function (e, t) { e.parentNode.querySelector(".emailoctopus-error-message").textContent = t, e.querySelector("[type=submit]").removeAttribute("disabled"), e.getAttribute("data-widget-id") && window.grecaptcha && window.grecaptcha.reset(e.getAttribute("data-widget-id")); var i = e.querySelector("input[name=recaptcha-response]"); i && i.remove() }, submit: function (e) { e.parentNode.querySelector(".emailoctopus-error-message").textContent = "", this.isBotPost(e) ? this.onError(e, this.getMessage("botSubmissionError")) : this.hasEmailAddressBeenEntered(e) ? this.isEmailAddressValid(e) ? this.consentRequired(e) ? this.onError(e, this.getMessage("consentRequired")) : this.ajaxSubmit(e) : this.onError(e, this.getMessage("invalidEmailAddress")) : this.onError(e, this.getMessage("missingEmailAddress")) } }, Be = document.querySelector(".emailoctopus-form"); Be.addEventListener("submit", (function (e) { Be.querySelector(".g-recaptcha") && !Be.querySelector("input[name=recaptcha-response]") || (e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), Le.submit(Be)) })); var Ye = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document || /(android)/i.test(navigator.userAgent); Be.querySelectorAll("input[type=date]").forEach((function (e) { if (Ye) e.addEventListener("focus", (function (e) { return e.target.classList.add("clicked") })); else { e.type = "text"; new Fe(e, { format: "yyyy-mm-dd" }) } })) } });